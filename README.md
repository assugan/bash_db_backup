# Резервное копирование СУБД *PostgreSQL*.

Скрипт автоматизирует резервное копирование PostgreSQL, создаёт дампы всех пользовательских баз,
архивирует их проверяет целостность архива, переносит на отдельный диск /backups,
ведёт логирование и выполняет ротацию старых бэкапов.

## Требования
### ПО

- **Linux**
- **Bash**
- **PostgreSQL**
- Утилиты:
  - `psql`
  - `pg_dump`
  - `tar`
  - `gzip`
  - `find`
- (опционально) **systemd** для сервиса/таймера

## PostgreSQL
### Установка на Ubuntu
```
sudo apt update
sudo apt install postgresql postgresql-client
sudo systemctl start postgresql
# Проверка
sudo systemctl status postgresql
which psql
which pg_dump
```
### Настройка
```
# Создать пользователя для бэкапов
sudo -u postgres psql
# Внутри psql
SET password_encryption = 'scram-sha-256';
CREATE USER backup_user WITH PASSWORD 'supersecret';

CREATE DATABASE testdb1;
CREATE DATABASE testdb2;

GRANT CONNECT ON DATABASE testdb1 TO backup_user;
GRANT CONNECT ON DATABASE testdb2 TO backup_user;
\q

# Права на объекты в базах
sudo -u postgres psql testdb1
# Внутри testdb1
GRANT USAGE ON SCHEMA public TO backup_user;
GRANT SELECT ON ALL TABLES IN SCHEMA public TO backup_user;
\q
```
## Структура файлов и директорий

/opt/pg_backup/
- `backup_pg.sh`      # основной скрипт резервного копирования
- `.env`              # настройки скрипта

Опционально:
/etc/systemd/system/
- `pg_backup.service` # systemd-сервис
- `pg_backup.timer`   # systemd-timer

## Дополнительные каталоги:

- `/tmp/pg_backups/`         # временные каталоги для дампов (создаются автоматически)
- `/backups/`                # каталог для хранения готовых архивов
- `/var/log/pg_backup.log`   # лог выполнения скрипта

## Как работает скрипт (пошагово)

Ниже приведена логика работы, полностью соответствующая внутренней структуре скрипта.

1. Загрузка переменных окружения \
Перед выполнением любых действий скрипт загружает `.env` \
Если файл отсутствует — процесс немедленно останавливается.

2. Проверка окружения \
    Функция `check_requirements` проверяет:
    - наличие утилит;
    - существование каталога `/backups`;
    - возможность работы с PostgreSQL.
    При любой ошибке - запись в лог и завершение.

3. Создание временного рабочего каталога \
    `init_backup()` создаёт каталог вида: \
    `/tmp/pg_backups/pg_backup_XXXXXX` \
    В него складываются дампы всех баз.

4. Получение списка баз данных \
    Функция `get_databases()` делает запрос: \
    `SELECT datname FROM pg_database WHERE datistemplate = false;`\
    Если после фильтрации не осталось ни одной пользовательской БД - скрипт завершает работу с ошибкой.

5. Создание дампов всех баз \
    Для каждой базы вызывается: \
    `pg_dump <dbname> > TMP_DIR/dbname.sql` \
    Если дамп любой БД завершился ошибкой — скрипт прекращает работу.

6. Архивирование всех SQL-файлов \
    Функция `create_archive()`:
    - упаковывает все дампы в архив `.tar.gz`;
    - архив создаётся прямо в `TMP_DIR`;
    - имя формируется по времени: \
    `pg_backup_YYYYMMDD_HHMMSS.tar.gz`

    Если tar не смог создать архив — скрипт завершает выполнение.

7. Проверка архива \
    Функция `test_archive()` проверяет архив командой: \
    `tar -tzf <archive>` \
    Если архив повреждён или неполный — скрипт логирует ошибку и завершается.

8. Перенос архива в `/backups` \
    `move_archive()` переносит готовый архив: \
    `mv TMP_DIR/pg_backup_xxx.tar.gz /backups/` \
    Если перемещение не удалось — ошибка и остановка.

9. Ротация старых архивов \
    `rotate_backups()` оставляет только последние `BACKUP_KEEP` архивов. \
    Алгоритм:
    - Находит все архивы по маске `pg_backup_*.tar.gz`
    - Сортирует по времени создания
    - Удаляет самые старые (если их больше заданного лимита)
    Все операции логируются.

10. Очистка временных файлов \
    По завершении работы (успешной или аварийной) выполняется `cleanup()`:
    - удаляется временный каталог с дампами;
    - в лог пишется сообщение об очистке.

## Дополнительно: systemd-сервис

Для автоматического запуска скрипта можно создать сервис:

Файл сервиса: \
`/etc/systemd/system/pg_backup.service` \
**Управление сервисом**
```
# Перечитать systemd:
`sudo systemctl daemon-reload`
# Однократный запуск:
`sudo systemctl start pg_backup.service`
# Включить автозапуск:
`sudo systemctl enable pg_backup.service`
```
Файл таймера: \
`/etc/systemd/system/pg_backup.timer`
```
# Активируем таймер:
sudo systemctl daemon-reload
sudo systemctl enable --now pg_backup.timer
```

## Где смотреть логи
- Основной лог скрипта: \
    `LOG_FILE` из `.env`, по умолчанию:
`/var/log/pg_backup.log`
- При запуске через systemd-сервис \
`sudo journalctl -u pg_backup.service`

## Проверка работы
Запуск скрипта \
`sudo /opt/pg_backup/backup_pg.sh`

1. **Нормальный сценарий** \
Запустить скрипт
```
sudo /opt/pg_backup/backup_pg.sh
# Вывод
[2025-11-21 16:26:20] [INFO]  Запуск скрипта резервного копирования PostgreSQL
[2025-11-21 16:26:20] [INFO]  Проверка окружения пройдена
[2025-11-21 16:26:20] [INFO]  Временный каталог создан: /tmp/pg_backups/pg_backup_1OpEHm
[2025-11-21 16:26:20] [INFO]  Получаем список баз данных
[2025-11-21 16:26:20] [INFO]  Баз для бэкапа: 2
[2025-11-21 16:26:20] [INFO]  Создаем дампы всех баз
[2025-11-21 16:26:20] [INFO]  Создаём дамп базы 'testdb1'
[2025-11-21 16:26:20] [INFO]  Дамп базы 'testdb1' создан
[2025-11-21 16:26:20] [INFO]  Создаём дамп базы 'testdb2'
[2025-11-21 16:26:20] [INFO]  Дамп базы 'testdb2' создан
[2025-11-21 16:26:20] [INFO]  Все дампы созданы успешно
[2025-11-21 16:26:20] [INFO]  Создаём архив: /tmp/pg_backups/pg_backup_1OpEHm/pg_backup_20251121_162620.tar.gz
[2025-11-21 16:26:20] [INFO]  Архив успешно создан
[2025-11-21 16:26:20] [INFO]  Тестируем архив
[2025-11-21 16:26:20] [INFO]  Архив прошёл проверку
[2025-11-21 16:26:20] [INFO]  Переносим архив в /backups
[2025-11-21 16:26:20] [INFO]  Архив перемещён в /backups/pg_backup_20251121_162620.tar.gz
[2025-11-21 16:26:20] [INFO]  Запускаем ротацию бэкапов (хранить только 5)
[2025-11-21 16:26:20] [INFO]  Ротация не требуется: бэкапов всего 4
[2025-11-21 16:26:20] [INFO]  Бэкап успешно завершён
[2025-11-21 16:26:20] [INFO]  Временный каталог /tmp/pg_backups/pg_backup_1OpEHm удален
```
Проверить:
- наличие нового архива в `/backups`;
- что временные каталоги в `/tmp/pg_backups` удалены;
- что в `/var/log/pg_backup.log` есть лог успешного выполнения.

2. **Неверный пароль от БД** \
В `.env` временно указать неправильный пароль: \
`PGPASSWORD=bad_password`

Запустить скрипт \
Ожидаемое поведение:
- ошибка на этапе `get_databases`;
- в логах сообщение об ошибке подключения/получения списка баз;
- дампы, архив и ротация не выполняются;
- временный каталог удалён.

После проверки вернуть корректный пароль.

3. **Ошибка создания дампа** \
    Самый простой способ — создать таблицу и отобрать у `backup_user` права `SELECT`. \
    Создать таблицу \
    `sudo -u postgres psql testdb` \
    Внутри
    ```
    CREATE TABLE data (id INT, name TEXT);
    INSERT INTO data VALUES (1, 'Hello');
    \q
    ```
    Убрать права \
    `sudo -u postgres psql testdb1 -c "REVOKE SELECT ON ALL TABLES IN SCHEMA public FROM backup_user;"` \
    Запустить скрипт \
    Ожидаемое поведение:
    - pg_dump вернёт ошибку прав доступа;
    - скрипт залогирует ошибку дампа и завершит работу;
    - архив не будет создан/перенесён.

    После теста вернуть права \
    `sudo -u postgres psql testdb1 -c "GRANT SELECT ON ALL TABLES IN SCHEMA public TO backup_user;"`

4. **Ошибка проверки архива** \
    Временно можно добавить в `create_archive()` строку (для теста) \
    `truncate -s 50 "$ARCHIVE_PATH"` \
    Сценарий:
    - Вставить `truncate` в конец `create_archive()`.
    - Запустить скрипт.
    - Ожидаемое поведение:
        - `tar -tzf` не сможет прочитать архив;
        - скрипт залогирует "Архив поврежден" и завершит работу;
        - архив не переносится в `/backups`.

    После теста удалить строку truncate из скрипта.

5. **Ошибка при недостатке свободного места на диске** \
    Создадим файл, который забьёт раздел `/tmp` или `/backups` под завязку. \
    `sudo dd if=/dev/zero of=/tmp/bigfile bs=100M count=1000` \
    Запуск скрипта \
    Ожидаемое поведение
    - скрипт завершится с ошибкой на этапе `create_archive`
    - в лог будет записано: Ошибка создания архива
    - процесс остановится, архив не будет создан
    - перенос архива и ротация не выполняются
    - временный каталог будет очищен \
    После теста удаляем фейковый файл \
    `sudo rm -f /tmp/bigfile`
